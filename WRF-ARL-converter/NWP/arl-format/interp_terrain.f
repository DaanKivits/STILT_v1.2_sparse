! Use emacs f90-mode:   -*- mode:f90  -*-
PROGRAM interp_terrain

!-------------------------------------------------------------------------------
! Simple program for horizontal interpolation of 2d fields from ARL file
! to lat/lon locations specified in input ASCII file (one line per point)
! (as generated by the R function write.table of a STILT times objects).
!
! By default, will do terrain processing:
!    Read in msl of points and output terrain height and agl
!    (For backwards compatibility with msl2agl.r)
!
! If specified otherwise (-M NULL and/or multiple -T outvar specifications),
! will interpolate one or more fields from file and write them out in 
! multi-column ASCII output file (one line per point).
!    (See arl2swmap in MakeModelSwTemp.r for an R wrapper.)
!
! Will process one time period of the ARL file at a time (-R itime_in).
!
! $Log: interp_terrain.f,v $
! Revision 1.11  2013/12/18 15:43:42  mellis
! mods related to working with GEOS global grid
!
! Revision 1.11  2013/12/18 15:43:42  mellis
! mods related to working with GEOS global grid
!
! Revision 1.10  2013/09/26 20:19:31  trn
! Fixed the logic that was broken with the introduction of the keep-missing option (r 1.5)
!
! Revision 1.9  2013/08/01 20:57:39  trn
! Added iprint argument to unpack
!
! Revision 1.8  2013/07/31 19:45:14  trn
! First revisions for interp_receptors
!
! Revision 1.7  2013/03/12 17:16:47  trn
! bug fix
!
! Revision 1.6  2013/03/12 16:35:42  trn
! Additions to support extra-long label/header for large nlvl
!
! Revision 1.5  2013/02/15 21:27:17  jmh
! added capability to preserve all receptor locations via keep_missing argument
!
! Revision 1.4  2011/06/14 22:04:45  trn
! Mostly cosmetic changes; use zero buffer by default
!
! Revision 1.3  2011/06/14 19:33:58  jhegarty
! Jennifer Hegarty: Added capability to include a buffer zone within domain
!
! Revision 1.2  2008/06/13 13:17:19  trn
! Add support for interpolating other variables, suppressing terrain processing
!
! Revision 1.1  2007/12/03 18:15:04  trn
! Added terrain interpolation program
!
!
! Initial revision: based on chk_data.f, Revision 1.9  2007/04/17 17:40:12  trn
!
!-------------------------------------------------------------------------------

  use interp_subs
  use unpack_subs

  implicit none

  REAL,          ALLOCATABLE :: RDATA(:,:,:)   
  CHARACTER(1),  ALLOCATABLE :: CPACK(:)

  integer, parameter :: max_allvars=20
  CHARACTER(2)               :: cgrid
  integer                    :: knx, kny
  CHARACTER(4)               :: KVAR, MODEL 
  CHARACTER(52)              :: LABEL, var_names(max_allvars)
  character(len=52)          :: lat_name='LAT',lon_name='LON',msl_name='MSL',agl_name='AGL'
  character(len=52)          :: ter_name='TER', outfmt
  real                       :: var_vals(max_allvars)
  integer                    :: lat_ind=0,lon_ind=0,msl_ind=0,agl_ind=0,ter_ind=0, nvars_in, nvars_out
  real                       :: missval
  logical                    :: keep_missing=.FALSE.
  CHARACTER(256)             :: FILE, intimes, outtimes, inline, outline, fmt
  integer, parameter :: maxlenh=15000
  CHARACTER(maxlenh)            :: HEADER
  integer :: k108, recl_k108, k50
  LOGICAL                    :: FTEST
  
  integer :: i, icurrent, ierr_interp, indblank, indend, indmax, indstart

  INTEGER  :: NEXP,i1,i2,di,j1,j2,dj, kret, k, krec, IY,IM,ID,IH,IF,KL
  integer :: IYR,IMO,IDA,IHR,IFC,nxy,len
  integer ::          ICX,       MN,                                              &
         NX,       NY,        NZ,                                              &
         K_FLAG,   LENH

  integer :: ierr, itime, itime_in

  real ::  PREC,VAR1,                                                 &
         POLE_LAT, POLE_LON,  REF_LAT,                                         &
         REF_LON,  SIZE,      ORIENT,                                          &
         TANG_LAT, SYNC_XP,   SYNC_YP,                                         &
         SYNC_LAT, SYNC_LON,  DUMMY

  integer :: iroot,ivar,nvars,ioutvar,noutvar
  integer, allocatable :: outunits(:)
  integer, parameter :: maxvars=10
  character (len=4) :: outvar(maxvars)
  character (len=256) :: outfname
  real :: xi_coord, xj_coord
  logical :: use_16, continue_reading, found_outvar(maxvars), skip_row
  integer :: kol, l, num_varb
  real :: height

  integer :: iarg, narg, iargc, iprint, iline, interp_type
  CHARACTER(256)             :: option, fname
  logical :: lhelp
  real :: bufxkm, bufykm, bufix, bufjy

  i1=1
  di=50
  i2=-1
  j1=1
  dj=50
  j2=-1
  use_16 = .FALSE.

!=>check for command line arguments
  NARG=IARGC()

  lhelp = narg .eq. 0

!     process options
  itime_in = 1
  iarg = 0
  FILE=' '
  intimes=' '
  outtimes=' '
  outvar(1) = 'SHGT'  ! defaults to terrain height
  noutvar = 0
  iprint=2
  bufxkm=0.0     ! For backwards compatibility, use no buffer by default
  bufykm=0.0
  interp_type=1  ! default to bilinear

  do while (iarg .lt. narg .and. .not. lhelp)
     iarg=iarg+1
     CALL GETARG(iarg,option)
     if (option(1:1) .ne. '-') exit
     iarg=iarg+1
     CALL GETARG(iarg,fname)
     SELECT CASE (option)
     CASE ('-A','-a')
        FILE = fname
     CASE ('-B','-b')
        read(fname,*,iostat=ierr) interp_type
        if (ierr .ne. 0) then
           write (*,*) 'Error decoding interp_type from -B option:',trim(fname)
           lhelp = .TRUE.
        endif
     CASE ('-I','-i')
        intimes = fname
     CASE ('-M','-m')
        msl_name = fname
     CASE ('-K','-k')
        read(fname,*,iostat=ierr) missval
        keep_missing = .TRUE.
     CASE ('-O','-o')
        outtimes = fname
     CASE ('-P','-p')
        SELECT CASE (fname)
        CASE ('16')
           use_16 = .TRUE.
        CASE ('8')
           use_16 = .FALSE.
        CASE DEFAULT
           write (*,*) 'Invalid value for -P option:',trim(fname)
           lhelp=.TRUE.
        end SELECT
     CASE ('-R','-r')
        read(fname,*,iostat=ierr) itime_in
        if (ierr .ne. 0) then
           write (*,*) 'Error decoding itime_in from -R option:',trim(fname)
           lhelp = .TRUE.
        endif
     CASE ('-T','-t')
        noutvar=noutvar + 1
        if (noutvar .gt. maxvars) then
           write (*,*) 'Too many -T outvars specified, maximum allowed is maxvars=',maxvars
           lhelp = .TRUE.
        else
           outvar(noutvar) = fname
        endif
     CASE ('-V','-v')
        read(fname,*,iostat=ierr) iprint
        if (ierr .ne. 0) then
           write (*,*) 'Error decoding iprint from -V option:',trim(fname)
           lhelp = .TRUE.
        endif
     CASE ('-X','-x')
        read(fname,*,iostat=ierr) bufxkm
     CASE ('-Y','-y')
        read(fname,*,iostat=ierr) bufykm
     CASE DEFAULT
        write (*,*) 'Invalid option:',trim(option)
        lhelp=.TRUE.
     END SELECT
  end do

  lhelp = lhelp .or. FILE .eq. ' ' .or. intimes .eq. ' ' .or. outtimes .eq. ' '
  lhelp = lhelp .or. iarg .gt. narg
  if (noutvar .lt. 1) noutvar=1
  if (noutvar .gt. 1 .and. trim(msl_name) .ne. 'NULL') then
     write (*,*) 'WARNING: Resetting msl_name to NULL because more than one outvar specified'
     msl_name = 'NULL'
  endif
  write (*,'(a)') 'Running interp_terrain $Revision: 1.11 $ with the following options:'
  write (*,'(a,t50,a)') 'REQUIRED: Input ARL file [-A]:',trim(FILE)
  write (*,'(a,t50,a)') 'REQUIRED: Input times object file [-I]:',trim(intimes)
  write (*,'(a,t50,a)') 'REQUIRED: Output times object file [-O]:',trim(outtimes)
  write (*,'(a,t50,l1)') 'Flag for 16-bit ARL precision [-P 16/-P 8]: ',use_16
  do ioutvar=1,noutvar
     write (*,'(a,t50,a)') 'Output variable name(s) in input',trim(outvar(ioutvar))
  enddo
  write (*,'(a,t50,a)') 'MSL variable name',trim(msl_name),'  (use NULL to suppress terrain processing)'
  write (*,'(a,t50,i10)') 'Printout control [-V]:',iprint
  write (*,'(a,t50,i10)') 'Input file time period number [-R]:',itime_in
  if (keep_missing) then
     write (*,'(a,t50,g15.6)') 'Missing value indicator [-K]:',missval
  else
     write (*,'(a)') 'Not keeping points outside domain, use -K missval to change this'
  end if
  write (*,'(a,t50,i10)') 'Interpolation type [-B, 0:nearest neighbor, 1:bilinear]:',interp_type
  write (*,'(a,t50,g15.6)') 'Buffer zone (km) in x-direction [-X]:',bufxkm
  write (*,'(a,t50,g15.6)') 'Buffer zone (km) in y-direction [-Y]:',bufykm
  
  if (iprint .lt. 2) i1 = -1

  if (lhelp) then
     write (*,'(a)') 'Usage: '
     write (*,'(2a)') '  interp_terrain -A arl_filename -I in_times_filename', &
          &' -O out_times_filename [-T outvar [-T outvar] ...] [-P 16/8] [-V iprint] [-B 0/1] [-K missval] [-M msl_name] [-X bufxkm] [-Y bufykm]'
     stop 'Usage'
  endif

! test for meteo file existence
  INQUIRE(FILE=FILE,EXIST=FTEST)
  IF(.NOT.FTEST)THEN
     WRITE(*,*)'Unable to find file: ',trim(FILE)
     STOP
  END IF

! open file to decode the standard label (50) plus the
! fixed portion (108) of the extended header
  k108=108
  k50=50
  recl_k108 = k108+k50
  fmt='(A4,I3,I2,12F7.0,3I3,I2,I4)'
  OPEN(10,FILE=FILE,RECL=recl_k108,ACCESS='DIRECT',FORM='UNFORMATTED')
  READ(10,REC=1)LABEL(1:k50),HEADER(1:k108)
  if (LABEL(11:11) .eq. 'X') then
     k50=52
     recl_k108 = k108+k50
     write (*,'(a,i5)') &
          'NOTE: Detected extra-long label with label length k50=',k50
     close(10)
     OPEN(10,FILE=FILE,RECL=recl_k108,ACCESS='DIRECT',FORM='UNFORMATTED')
     READ(10,REC=1)LABEL(1:k50),HEADER(1:k108)
  endif
! decode extended portion of the header
  if (header(105:105) .eq. 'X') then
     k108=110
     fmt='(A4,I3,I2,12F7.0,3I3,I2,1x,I5)'
     recl_k108 = k108+k50
     write (*,'(a,i5)') &
          'NOTE: Detected extra-long header with standard header length k108=',k108
     close(10)
     OPEN(10,FILE=FILE,RECL=recl_k108,ACCESS='DIRECT',FORM='UNFORMATTED')
     READ(10,REC=1)LABEL(1:K50),HEADER(1:k108)
  end if
  
! decode the standard portion of the index record
  ! From metset.f: read in cgrid
  if (k50 .eq. 50) then
     READ(LABEL,'(5I2,2X,a2,A4)')IYR,IMO,IDA,IHR,IFC,cgrid,KVAR
  else
     READ(LABEL,'(5I2,4X,a2,A4)')IYR,IMO,IDA,IHR,IFC,cgrid,KVAR
  end if
  WRITE(*,'(A,4I5)')'Opened file       : ',IYR,IMO,IDA,IHR

  IF(KVAR.NE.'INDX')THEN
     WRITE(*,*)'WARNING Old format meteo data grid'
     WRITE(*,*)LABEL(1:K50)
     WRITE(*,*)HEADER(1:k108)
     STOP
  END IF

! decode extended portion of the header
  READ(HEADER(1:k108),fmt,iostat=ierr)                &
         MODEL,    ICX,       MN,                                              &
         POLE_LAT, POLE_LON,  REF_LAT,                                         &
         REF_LON,  SIZE,      ORIENT,                                          &
         TANG_LAT, SYNC_XP,   SYNC_YP,                                         &
         SYNC_LAT, SYNC_LON,  DUMMY,                                           &
         NX,       NY,        NZ,                                              &
         K_FLAG,   LENH

  if (ierr .ne. 0) then
     WRITE(*,'(a)') 'ERROR: decoding first header, cannot recover'
     WRITE(*,'(2a)') 'LABEL=',LABEL(1:K50)
     WRITE(*,'(2a)') 'HEADER=',HEADER(1:k108)
  end if

  ! From metset.f:
  KNX=ICHAR(CGRID(1:1))
  KNY=ICHAR(CGRID(2:2))
  IF(KNX.GE.64.OR.KNY.GE.64)THEN
     NX=(KNX-64)*1000+NX
     NY=(KNY-64)*1000+NY
!!$     GRID(KG,KT)%NUMBER=KNX*10+KNY
!!$  ELSE
!!$     READ(CGRID,'(I2)')IGRID
!!$     GRID(KG,KT)%NUMBER=IGRID
  END IF

! close file and reopen with proper length
  CLOSE (10)
  NXY = NX*NY
  if (use_16) nxy=2*nxy
  LEN = NXY+k50
  OPEN(10,FILE=FILE,RECL=LEN,ACCESS='DIRECT',FORM='UNFORMATTED')
  if (i1 .lt. 0) i1=nx+1
  if (j1 .lt. 0) j1=ny+1
  if (i2 .lt. 0) i2=nx
  if (j2 .lt. 0) j2=ny

! print file diagnostic
  if (iprint .gt. 0) WRITE(*,'(A,4I8)')'Grid size and lrec: ',NX,NY,NXY,LEN
  if (iprint .gt. 0) WRITE(*,'(A,I5)') 'Header record size: ',LENH

! allocate array space
  ALLOCATE (RDATA(NX,NY,noutvar))   
  ALLOCATE (CPACK(NXY))

! read entire file and print headers
  KREC=1
  itime = 0
  continue_reading = .TRUE.
  found_outvar(:) = .FALSE.
  READ_LOOP: do while (continue_reading)
     READ(10,REC=KREC,iostat=ierr)LABEL(1:K50),(CPACK(K),K=1,NXY)
     if (ierr .ne. 0) then
        write (*,*) 'Read error ierr= ',ierr,' at krec= ',krec
        continue_reading=.FALSE.
        cycle READ_LOOP
     end if
     
     if (k50 .eq. 50) then
        READ(LABEL(1:k50),'(6I2,a2,A4,I4,2E14.7)',iostat=ierr) IY,IM,ID,IH,IF,KL,  &
             cgrid,KVAR,NEXP,PREC,VAR1
     else
        READ(LABEL(1:k50),'(5I2,1x,i3,a2,A4,I4,2E14.7)',iostat=ierr) IY,IM,ID,IH,IF,KL,  &
             cgrid,KVAR,NEXP,PREC,VAR1
     end if

     if (ierr .ne. 0) then
        WRITE(*,'(a)') 'ERROR: decoding LABEL, going on to next record'
        WRITE(*,'(2a)') 'LABEL=',LABEL(1:K50)
        WRITE(*,'(2a)') 'HEADER=',HEADER(1:k108)
        krec=krec+1
        cycle READ_LOOP
     end if

     if (kvar .eq. 'INDX' .or. itime .eq. 0) then
        if (lenh .gt. maxlenh .or. lenh .gt. nxy) then
           write (*,*) 'Warning: ignoring header characters from ',min(maxlenh,nxy), &
                & ' to ',lenh
           lenh=min(maxlenh,nxy)
        end if
        do k=1,lenh
           header(k:k) = cpack(k)
        enddo
        if (iprint .gt. 0) WRITE(*,'(A,1x,a)') LABEL(1:K50),header(1:k108)
! decode extended portion of the header
        READ(HEADER(1:k108),fmt,iostat=ierr)              &
             MODEL,    ICX,       MN,                                              &
             POLE_LAT, POLE_LON,  REF_LAT,                                         &
             REF_LON,  SIZE,      ORIENT,                                          &
             TANG_LAT, SYNC_XP,   SYNC_YP,                                         &
             SYNC_LAT, SYNC_LON,  DUMMY,                                           &
             NX,       NY,        NZ,                                              &
             K_FLAG,   LENH
        if (ierr .ne. 0) then
           WRITE(*,'(a)') 'ERROR: decoding HEADER'
           WRITE(*,'(2a)') 'LABEL=',LABEL(1:K50)
           WRITE(*,'(2a)') 'HEADER=',HEADER(1:k108)
        end if
        ! From metset.f:
        KNX=ICHAR(CGRID(1:1))
        KNY=ICHAR(CGRID(2:2))
        IF(KNX.GE.64.OR.KNY.GE.64)THEN
           NX=(KNX-64)*1000+NX
           NY=(KNY-64)*1000+NY
!!$        GRID(KG,KT)%NUMBER=KNX*10+KNY
!!$     ELSE
!!$        READ(CGRID,'(I2)')IGRID
!!$        GRID(KG,KT)%NUMBER=IGRID
        END IF
        itime = itime + 1
     else
        if (itime .eq. itime_in) then
           if (iprint .gt. 0) WRITE(*,'(A)')LABEL(1:K50)
           do ioutvar=1,noutvar
              if (kvar .eq. outvar(ioutvar)) then
                 CALL UNPACK(label,icx,mn,CPACK,RDATA(1,1,ioutvar),NX,NY,NEXP,PREC,VAR1, &
                      &    i1,i2,di,j1,j2,dj, &
                      &    use_16,iprint)
                 if (found_outvar(ioutvar)) &
                      & write (*,*) 'WARNING: Found duplicate match for outvar=',outvar(ioutvar)
                 found_outvar(ioutvar) = .TRUE.
                 continue_reading = .not. all(found_outvar(1:noutvar))
              endif
           end do
        end if
        
     end if

     KREC=KREC+1
  end do READ_LOOP
  
  if (.not. all(found_outvar(1:noutvar))) then
     write (*,*) 'Some of outvar =',outvar(1:noutvar),' not found in input, aborting'
     write (*,*) 'Had read in ',itime,' time periods from input file'
     stop 'Some of outvar not found in input, aborting'
  end if
  
! open input and output times files
  write (*,*) 'Reading input times object from file: ',trim(intimes)
  open(unit=11,file=intimes,status='old',iostat=ierr)
  if (ierr .ne. 0) then
     write (*,*) 'Error opening intimes file: ',trim(intimes),' ierr=',ierr
     Stop 'error opening intimes file'
  end if
  write (*,*) 'Writing output times object to file: ',trim(outtimes)
  open(unit=12,file=outtimes,status='unknown',iostat=ierr)
  if (ierr .ne. 0) then
     write (*,*) 'Error opening outtimes file: ',trim(outtimes),' ierr=',ierr
     Stop 'error opening outtimes file'
  end if
  
! Read and decode header

  read(11,'(a)',iostat=ierr) inline
  if (ierr .ne. 0) then
     write (*,*) 'Error reading header from intimes file: ',trim(intimes),' ierr=',ierr
     Stop 'error reading header from intimes file'
  end if

  indmax = len_trim(inline)
  indblank = 0
  indstart = 0
  nvars_in = 0
  icurrent = 1
  do while ( nvars_in .lt. max_allvars .and. icurrent .lt. indmax)
!    start of variable name: look for first non-blank character in remaining subtring
     indstart = verify(inline(icurrent:indmax),' ')
     if (indstart .eq. 0) exit
     indstart = indstart + icurrent - 1
!    end of variable name: look for first blank character following the variable name
     indblank = index(inline(indstart:indmax),' ')
     if (indblank .eq. 0) indblank = indmax-indstart+2 !case of the last variable name
     indend = indblank + indstart - 2
!    store variable name, go on to next one
     nvars_in = nvars_in + 1
     var_names(nvars_in) = inline(indstart:indend)
     write (*,*) 'Decoded input variable ',nvars_in,' :',trim(var_names(nvars_in))
     if (trim(var_names(nvars_in)) .eq. trim(lat_name)) lat_ind=nvars_in
     if (trim(var_names(nvars_in)) .eq. trim(lon_name)) lon_ind=nvars_in
     if (trim(var_names(nvars_in)) .eq. trim(msl_name)) msl_ind=nvars_in
     icurrent = indend + 1
  end do

  if (lat_ind .eq. 0 .or. lon_ind .eq. 0 .or. &
       & (msl_ind .eq. 0 .and. trim(msl_name) .ne. 'NULL')) then
     write (*,*) 'Missing a required input variable (index=0):'
     write (*,*) ' latitude:   name=',trim(lat_name),' index=',lat_ind
     write (*,*) ' longitude:  name=',trim(lon_name),' index=',lon_ind
     if (trim(msl_name) .ne. 'NULL') &
          & write (*,*) ' MSL height: name=',trim(msl_name),' index=',msl_ind
     stop 'Missing a required input variable'
  end if
  
! Generate and output header to output file

  nvars_out=nvars_in
  outline = trim(inline)
  do ioutvar=1,noutvar
     nvars_out = nvars_out + 1
     if (nvars_out .gt. max_allvars) then
        write (*,*) 'Too many variables for output file, maximum allowable is max_allvars=',max_allvars
        stop 'max_allvars'
     endif
     if (trim(msl_name) .ne. 'NULL') then
        ter_ind = nvars_out
        var_names(nvars_out) = ter_name
        outline = trim(outline) // ' ' // trim(ter_name) 
        nvars_out = nvars_out + 1
        if (nvars_out .gt. max_allvars) then
           write (*,*) 'Too many variables for output file, maximum allowable is max_allvars=',max_allvars
           stop 'max_allvars'
        endif
        agl_ind = nvars_out
        var_names(agl_ind) = agl_name
        outline = trim(outline) // ' ' // trim(agl_name)
     else
        var_names(nvars_out) = outvar(ioutvar)
        outline = trim(outline) // ' ' // trim(outvar(ioutvar)) 
     endif
  enddo

  write (12,'(a)') trim(outline)
  write (outfmt,'(a,i2,a)') '(',nvars_out,'f12.4)' 

! Process and output data to output file

  ierr = 0
  iline = 1
! Add a buffer zone defined by bufxkm,and bufykm within 
! the edge of the current domain. SIZE is the horizontal
! grid spacing.  ! This will not work for LATLON grids.

  if(size .ne. 0) then
     bufix=bufxkm/size
     bufjy=bufykm/size
     if (iprint .gt. 0) write(*,*) 'Based on grid spacing of size=',size,', using:', &
          ' bufix=',bufix,', bufjy=',bufjy
  else
     write(*,*) 'LATLON grid (size=0), no buffer zone defined.'
     bufix=0.0
     bufjy=0.0
  end if

  do while ( ierr .eq. 0)
     var_vals(:)=0
     iline = iline + 1
     read(11,*,iostat=ierr) (var_vals(i), i=1,nvars_in)
     if (ierr .ne. 0) then
        write (*,*) 'Hit read error at line ',iline,' of ',trim(intimes),' with ierr=',ierr
     else
        skip_row = .FALSE.
        do ioutvar=1,noutvar
           call interp_2d(var_vals(lon_ind),var_vals(lat_ind),rdata(1,1,ioutvar), &
                nx,ny,header,maxlenh,var_vals(nvars_in+ioutvar),ierr_interp,iprint, &
                bufix,bufjy,interp_type,label)
           if (ierr_interp .ne. 0) then !point is not in domain
              skip_row = .TRUE.
              write (*,*) 'Warning: ierr_interp= ',ierr_interp,', skipping row flag=',skip_row
              var_vals(nvars_in+ioutvar) = missval
           endif
        end do

        if (.not. skip_row .or. keep_missing) then ! keep all rows
           if (trim(msl_name) .ne. 'NULL' .and. .not. skip_row) &
                 var_vals(agl_ind) = var_vals(msl_ind) - var_vals(ter_ind)
           write (12,outfmt) (var_vals(i),i=1,nvars_out)
        endif
     end if
  end do

  close(11)
  close(12)

  write (*,*) 'Normal Program Stop'

end PROGRAM interp_terrain
